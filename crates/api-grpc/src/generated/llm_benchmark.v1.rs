// This file is @generated by prost-build.
/// Benchmark metadata
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BenchmarkMetadata {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub slug: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub long_description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "5")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(enumeration = "LicenseType", tag = "6")]
    pub license: i32,
    #[prost(message, optional, tag = "7")]
    pub custom_license: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "8")]
    pub citation: ::core::option::Option<Citation>,
    #[prost(message, optional, tag = "9")]
    pub documentation_url: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "10")]
    pub source_url: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "11")]
    pub maintainer_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Academic citation
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Citation {
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub authors: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "3")]
    pub venue: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, tag = "4")]
    pub year: u32,
    #[prost(message, optional, tag = "5")]
    pub doi: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "6")]
    pub bibtex: ::core::option::Option<::prost::alloc::string::String>,
}
/// Full benchmark definition
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Benchmark {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub metadata: ::core::option::Option<BenchmarkMetadata>,
    #[prost(enumeration = "BenchmarkCategory", tag = "3")]
    pub category: i32,
    #[prost(enumeration = "BenchmarkStatus", tag = "4")]
    pub status: i32,
    #[prost(string, tag = "5")]
    pub version: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub version_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "7")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "8")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "9")]
    pub created_by: ::prost::alloc::string::String,
}
/// Create benchmark request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateBenchmarkRequest {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<BenchmarkMetadata>,
    #[prost(enumeration = "BenchmarkCategory", tag = "2")]
    pub category: i32,
    #[prost(string, tag = "3")]
    pub version: ::prost::alloc::string::String,
}
/// Create benchmark response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateBenchmarkResponse {
    #[prost(message, optional, tag = "1")]
    pub benchmark: ::core::option::Option<Benchmark>,
}
/// Get benchmark request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBenchmarkRequest {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub version: ::core::option::Option<::prost::alloc::string::String>,
}
/// Get benchmark response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBenchmarkResponse {
    #[prost(message, optional, tag = "1")]
    pub benchmark: ::core::option::Option<Benchmark>,
}
/// List benchmarks request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBenchmarksRequest {
    #[prost(enumeration = "BenchmarkCategory", tag = "1")]
    pub category: i32,
    #[prost(enumeration = "BenchmarkStatus", tag = "2")]
    pub status: i32,
    #[prost(string, repeated, tag = "3")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "4")]
    pub search_query: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, tag = "5")]
    pub page: u32,
    #[prost(uint32, tag = "6")]
    pub page_size: u32,
    #[prost(string, tag = "7")]
    pub sort_by: ::prost::alloc::string::String,
    #[prost(bool, tag = "8")]
    pub sort_desc: bool,
}
/// List benchmarks response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBenchmarksResponse {
    #[prost(message, repeated, tag = "1")]
    pub benchmarks: ::prost::alloc::vec::Vec<Benchmark>,
    #[prost(uint32, tag = "2")]
    pub total_count: u32,
    #[prost(uint32, tag = "3")]
    pub page: u32,
    #[prost(uint32, tag = "4")]
    pub page_size: u32,
}
/// Update benchmark request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateBenchmarkRequest {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub metadata: ::core::option::Option<BenchmarkMetadata>,
}
/// Update benchmark response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateBenchmarkResponse {
    #[prost(message, optional, tag = "1")]
    pub benchmark: ::core::option::Option<Benchmark>,
}
/// Submit for review request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubmitForReviewRequest {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
/// Submit for review response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubmitForReviewResponse {
    #[prost(message, optional, tag = "1")]
    pub benchmark: ::core::option::Option<Benchmark>,
}
/// Approve benchmark request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApproveBenchmarkRequest {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub review_notes: ::core::option::Option<::prost::alloc::string::String>,
}
/// Approve benchmark response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApproveBenchmarkResponse {
    #[prost(message, optional, tag = "1")]
    pub benchmark: ::core::option::Option<Benchmark>,
}
/// Reject benchmark request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RejectBenchmarkRequest {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub reason: ::prost::alloc::string::String,
}
/// Reject benchmark response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RejectBenchmarkResponse {
    #[prost(message, optional, tag = "1")]
    pub benchmark: ::core::option::Option<Benchmark>,
}
/// Benchmark categories
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BenchmarkCategory {
    Unspecified = 0,
    Performance = 1,
    Accuracy = 2,
    Reliability = 3,
    Safety = 4,
    Cost = 5,
    Capability = 6,
}
impl BenchmarkCategory {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            BenchmarkCategory::Unspecified => "BENCHMARK_CATEGORY_UNSPECIFIED",
            BenchmarkCategory::Performance => "BENCHMARK_CATEGORY_PERFORMANCE",
            BenchmarkCategory::Accuracy => "BENCHMARK_CATEGORY_ACCURACY",
            BenchmarkCategory::Reliability => "BENCHMARK_CATEGORY_RELIABILITY",
            BenchmarkCategory::Safety => "BENCHMARK_CATEGORY_SAFETY",
            BenchmarkCategory::Cost => "BENCHMARK_CATEGORY_COST",
            BenchmarkCategory::Capability => "BENCHMARK_CATEGORY_CAPABILITY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BENCHMARK_CATEGORY_UNSPECIFIED" => Some(Self::Unspecified),
            "BENCHMARK_CATEGORY_PERFORMANCE" => Some(Self::Performance),
            "BENCHMARK_CATEGORY_ACCURACY" => Some(Self::Accuracy),
            "BENCHMARK_CATEGORY_RELIABILITY" => Some(Self::Reliability),
            "BENCHMARK_CATEGORY_SAFETY" => Some(Self::Safety),
            "BENCHMARK_CATEGORY_COST" => Some(Self::Cost),
            "BENCHMARK_CATEGORY_CAPABILITY" => Some(Self::Capability),
            _ => None,
        }
    }
}
/// Benchmark lifecycle status
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BenchmarkStatus {
    Unspecified = 0,
    Draft = 1,
    UnderReview = 2,
    Active = 3,
    Deprecated = 4,
    Archived = 5,
}
impl BenchmarkStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            BenchmarkStatus::Unspecified => "BENCHMARK_STATUS_UNSPECIFIED",
            BenchmarkStatus::Draft => "BENCHMARK_STATUS_DRAFT",
            BenchmarkStatus::UnderReview => "BENCHMARK_STATUS_UNDER_REVIEW",
            BenchmarkStatus::Active => "BENCHMARK_STATUS_ACTIVE",
            BenchmarkStatus::Deprecated => "BENCHMARK_STATUS_DEPRECATED",
            BenchmarkStatus::Archived => "BENCHMARK_STATUS_ARCHIVED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BENCHMARK_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "BENCHMARK_STATUS_DRAFT" => Some(Self::Draft),
            "BENCHMARK_STATUS_UNDER_REVIEW" => Some(Self::UnderReview),
            "BENCHMARK_STATUS_ACTIVE" => Some(Self::Active),
            "BENCHMARK_STATUS_DEPRECATED" => Some(Self::Deprecated),
            "BENCHMARK_STATUS_ARCHIVED" => Some(Self::Archived),
            _ => None,
        }
    }
}
/// License types
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LicenseType {
    Unspecified = 0,
    Apache2 = 1,
    Mit = 2,
    Bsd3Clause = 3,
    CcBy40 = 4,
    CcBySa40 = 5,
    Custom = 6,
}
impl LicenseType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            LicenseType::Unspecified => "LICENSE_TYPE_UNSPECIFIED",
            LicenseType::Apache2 => "LICENSE_TYPE_APACHE_2",
            LicenseType::Mit => "LICENSE_TYPE_MIT",
            LicenseType::Bsd3Clause => "LICENSE_TYPE_BSD_3_CLAUSE",
            LicenseType::CcBy40 => "LICENSE_TYPE_CC_BY_4_0",
            LicenseType::CcBySa40 => "LICENSE_TYPE_CC_BY_SA_4_0",
            LicenseType::Custom => "LICENSE_TYPE_CUSTOM",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "LICENSE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "LICENSE_TYPE_APACHE_2" => Some(Self::Apache2),
            "LICENSE_TYPE_MIT" => Some(Self::Mit),
            "LICENSE_TYPE_BSD_3_CLAUSE" => Some(Self::Bsd3Clause),
            "LICENSE_TYPE_CC_BY_4_0" => Some(Self::CcBy40),
            "LICENSE_TYPE_CC_BY_SA_4_0" => Some(Self::CcBySa40),
            "LICENSE_TYPE_CUSTOM" => Some(Self::Custom),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod benchmark_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// BenchmarkService provides operations for managing benchmarks
    #[derive(Debug, Clone)]
    pub struct BenchmarkServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl BenchmarkServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> BenchmarkServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> BenchmarkServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            BenchmarkServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Create a new benchmark (draft state)
        pub async fn create_benchmark(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateBenchmarkRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateBenchmarkResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/llm_benchmark.v1.BenchmarkService/CreateBenchmark",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "llm_benchmark.v1.BenchmarkService",
                        "CreateBenchmark",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get a specific benchmark by ID
        pub async fn get_benchmark(
            &mut self,
            request: impl tonic::IntoRequest<super::GetBenchmarkRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetBenchmarkResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/llm_benchmark.v1.BenchmarkService/GetBenchmark",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("llm_benchmark.v1.BenchmarkService", "GetBenchmark"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// List benchmarks with filtering and pagination
        pub async fn list_benchmarks(
            &mut self,
            request: impl tonic::IntoRequest<super::ListBenchmarksRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListBenchmarksResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/llm_benchmark.v1.BenchmarkService/ListBenchmarks",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "llm_benchmark.v1.BenchmarkService",
                        "ListBenchmarks",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Update an existing benchmark
        pub async fn update_benchmark(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateBenchmarkRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateBenchmarkResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/llm_benchmark.v1.BenchmarkService/UpdateBenchmark",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "llm_benchmark.v1.BenchmarkService",
                        "UpdateBenchmark",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Submit a benchmark for review
        pub async fn submit_for_review(
            &mut self,
            request: impl tonic::IntoRequest<super::SubmitForReviewRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SubmitForReviewResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/llm_benchmark.v1.BenchmarkService/SubmitForReview",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "llm_benchmark.v1.BenchmarkService",
                        "SubmitForReview",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Approve a benchmark (requires reviewer role)
        pub async fn approve_benchmark(
            &mut self,
            request: impl tonic::IntoRequest<super::ApproveBenchmarkRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ApproveBenchmarkResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/llm_benchmark.v1.BenchmarkService/ApproveBenchmark",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "llm_benchmark.v1.BenchmarkService",
                        "ApproveBenchmark",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Reject a benchmark (requires reviewer role)
        pub async fn reject_benchmark(
            &mut self,
            request: impl tonic::IntoRequest<super::RejectBenchmarkRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RejectBenchmarkResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/llm_benchmark.v1.BenchmarkService/RejectBenchmark",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "llm_benchmark.v1.BenchmarkService",
                        "RejectBenchmark",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod benchmark_service_server {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with BenchmarkServiceServer.
    #[async_trait]
    pub trait BenchmarkService: Send + Sync + 'static {
        /// Create a new benchmark (draft state)
        async fn create_benchmark(
            &self,
            request: tonic::Request<super::CreateBenchmarkRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateBenchmarkResponse>,
            tonic::Status,
        >;
        /// Get a specific benchmark by ID
        async fn get_benchmark(
            &self,
            request: tonic::Request<super::GetBenchmarkRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetBenchmarkResponse>,
            tonic::Status,
        >;
        /// List benchmarks with filtering and pagination
        async fn list_benchmarks(
            &self,
            request: tonic::Request<super::ListBenchmarksRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListBenchmarksResponse>,
            tonic::Status,
        >;
        /// Update an existing benchmark
        async fn update_benchmark(
            &self,
            request: tonic::Request<super::UpdateBenchmarkRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateBenchmarkResponse>,
            tonic::Status,
        >;
        /// Submit a benchmark for review
        async fn submit_for_review(
            &self,
            request: tonic::Request<super::SubmitForReviewRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SubmitForReviewResponse>,
            tonic::Status,
        >;
        /// Approve a benchmark (requires reviewer role)
        async fn approve_benchmark(
            &self,
            request: tonic::Request<super::ApproveBenchmarkRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ApproveBenchmarkResponse>,
            tonic::Status,
        >;
        /// Reject a benchmark (requires reviewer role)
        async fn reject_benchmark(
            &self,
            request: tonic::Request<super::RejectBenchmarkRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RejectBenchmarkResponse>,
            tonic::Status,
        >;
    }
    /// BenchmarkService provides operations for managing benchmarks
    #[derive(Debug)]
    pub struct BenchmarkServiceServer<T: BenchmarkService> {
        inner: _Inner<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    struct _Inner<T>(Arc<T>);
    impl<T: BenchmarkService> BenchmarkServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            let inner = _Inner(inner);
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for BenchmarkServiceServer<T>
    where
        T: BenchmarkService,
        B: Body + Send + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/llm_benchmark.v1.BenchmarkService/CreateBenchmark" => {
                    #[allow(non_camel_case_types)]
                    struct CreateBenchmarkSvc<T: BenchmarkService>(pub Arc<T>);
                    impl<
                        T: BenchmarkService,
                    > tonic::server::UnaryService<super::CreateBenchmarkRequest>
                    for CreateBenchmarkSvc<T> {
                        type Response = super::CreateBenchmarkResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateBenchmarkRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as BenchmarkService>::create_benchmark(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = CreateBenchmarkSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/llm_benchmark.v1.BenchmarkService/GetBenchmark" => {
                    #[allow(non_camel_case_types)]
                    struct GetBenchmarkSvc<T: BenchmarkService>(pub Arc<T>);
                    impl<
                        T: BenchmarkService,
                    > tonic::server::UnaryService<super::GetBenchmarkRequest>
                    for GetBenchmarkSvc<T> {
                        type Response = super::GetBenchmarkResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetBenchmarkRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as BenchmarkService>::get_benchmark(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = GetBenchmarkSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/llm_benchmark.v1.BenchmarkService/ListBenchmarks" => {
                    #[allow(non_camel_case_types)]
                    struct ListBenchmarksSvc<T: BenchmarkService>(pub Arc<T>);
                    impl<
                        T: BenchmarkService,
                    > tonic::server::UnaryService<super::ListBenchmarksRequest>
                    for ListBenchmarksSvc<T> {
                        type Response = super::ListBenchmarksResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListBenchmarksRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as BenchmarkService>::list_benchmarks(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = ListBenchmarksSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/llm_benchmark.v1.BenchmarkService/UpdateBenchmark" => {
                    #[allow(non_camel_case_types)]
                    struct UpdateBenchmarkSvc<T: BenchmarkService>(pub Arc<T>);
                    impl<
                        T: BenchmarkService,
                    > tonic::server::UnaryService<super::UpdateBenchmarkRequest>
                    for UpdateBenchmarkSvc<T> {
                        type Response = super::UpdateBenchmarkResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpdateBenchmarkRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as BenchmarkService>::update_benchmark(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = UpdateBenchmarkSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/llm_benchmark.v1.BenchmarkService/SubmitForReview" => {
                    #[allow(non_camel_case_types)]
                    struct SubmitForReviewSvc<T: BenchmarkService>(pub Arc<T>);
                    impl<
                        T: BenchmarkService,
                    > tonic::server::UnaryService<super::SubmitForReviewRequest>
                    for SubmitForReviewSvc<T> {
                        type Response = super::SubmitForReviewResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SubmitForReviewRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as BenchmarkService>::submit_for_review(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = SubmitForReviewSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/llm_benchmark.v1.BenchmarkService/ApproveBenchmark" => {
                    #[allow(non_camel_case_types)]
                    struct ApproveBenchmarkSvc<T: BenchmarkService>(pub Arc<T>);
                    impl<
                        T: BenchmarkService,
                    > tonic::server::UnaryService<super::ApproveBenchmarkRequest>
                    for ApproveBenchmarkSvc<T> {
                        type Response = super::ApproveBenchmarkResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ApproveBenchmarkRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as BenchmarkService>::approve_benchmark(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = ApproveBenchmarkSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/llm_benchmark.v1.BenchmarkService/RejectBenchmark" => {
                    #[allow(non_camel_case_types)]
                    struct RejectBenchmarkSvc<T: BenchmarkService>(pub Arc<T>);
                    impl<
                        T: BenchmarkService,
                    > tonic::server::UnaryService<super::RejectBenchmarkRequest>
                    for RejectBenchmarkSvc<T> {
                        type Response = super::RejectBenchmarkResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RejectBenchmarkRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as BenchmarkService>::reject_benchmark(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = RejectBenchmarkSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        Ok(
                            http::Response::builder()
                                .status(200)
                                .header("grpc-status", "12")
                                .header("content-type", "application/grpc")
                                .body(empty_body())
                                .unwrap(),
                        )
                    })
                }
            }
        }
    }
    impl<T: BenchmarkService> Clone for BenchmarkServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    impl<T: BenchmarkService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(Arc::clone(&self.0))
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: BenchmarkService> tonic::server::NamedService for BenchmarkServiceServer<T> {
        const NAME: &'static str = "llm_benchmark.v1.BenchmarkService";
    }
}
/// Model information
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModelInfo {
    #[prost(message, optional, tag = "1")]
    pub model_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "2")]
    pub provider: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub model_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub model_version: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "5")]
    pub api_endpoint: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, tag = "6")]
    pub is_official: bool,
}
/// Submitter information
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubmitterInfo {
    #[prost(string, tag = "1")]
    pub user_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub organization_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, tag = "3")]
    pub is_verified_provider: bool,
}
/// Metric score
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetricScore {
    #[prost(double, tag = "1")]
    pub value: f64,
    #[prost(message, optional, tag = "2")]
    pub unit: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(double, repeated, tag = "3")]
    pub raw_values: ::prost::alloc::vec::Vec<f64>,
    #[prost(message, optional, tag = "4")]
    pub std_dev: ::core::option::Option<f64>,
}
/// Test case error
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TestCaseError {
    #[prost(enumeration = "TestCaseErrorType", tag = "1")]
    pub error_type: i32,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
}
/// Test case result
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TestCaseResult {
    #[prost(string, tag = "1")]
    pub test_case_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub passed: bool,
    #[prost(double, tag = "3")]
    pub score: f64,
    #[prost(message, optional, tag = "4")]
    pub latency_ms: ::core::option::Option<u64>,
    #[prost(message, optional, tag = "5")]
    pub tokens_generated: ::core::option::Option<u32>,
    #[prost(message, optional, tag = "6")]
    pub error: ::core::option::Option<TestCaseError>,
}
/// Confidence interval
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConfidenceInterval {
    #[prost(double, tag = "1")]
    pub lower: f64,
    #[prost(double, tag = "2")]
    pub upper: f64,
    #[prost(double, tag = "3")]
    pub confidence_level: f64,
}
/// Statistical significance
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StatisticalSignificance {
    #[prost(double, tag = "1")]
    pub p_value: f64,
    #[prost(double, tag = "2")]
    pub effect_size: f64,
    #[prost(uint32, tag = "3")]
    pub sample_size: u32,
    #[prost(string, tag = "4")]
    pub test_used: ::prost::alloc::string::String,
}
/// Submission results
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubmissionResults {
    #[prost(double, tag = "1")]
    pub aggregate_score: f64,
    #[prost(map = "string, message", tag = "2")]
    pub metric_scores: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        MetricScore,
    >,
    #[prost(message, repeated, tag = "3")]
    pub test_case_results: ::prost::alloc::vec::Vec<TestCaseResult>,
    #[prost(message, optional, tag = "4")]
    pub confidence_interval: ::core::option::Option<ConfidenceInterval>,
    #[prost(message, optional, tag = "5")]
    pub statistical_significance: ::core::option::Option<StatisticalSignificance>,
}
/// Model parameters
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModelParameters {
    #[prost(message, optional, tag = "1")]
    pub temperature: ::core::option::Option<f64>,
    #[prost(message, optional, tag = "2")]
    pub top_p: ::core::option::Option<f64>,
    #[prost(message, optional, tag = "3")]
    pub top_k: ::core::option::Option<u32>,
    #[prost(message, optional, tag = "4")]
    pub max_tokens: ::core::option::Option<u32>,
    #[prost(string, repeated, tag = "5")]
    pub stop_sequences: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "6")]
    pub random_seed: ::core::option::Option<u64>,
}
/// Hardware information
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HardwareInfo {
    #[prost(string, tag = "1")]
    pub cpu: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub cpu_cores: u32,
    #[prost(uint32, tag = "3")]
    pub memory_gb: u32,
    #[prost(message, optional, tag = "4")]
    pub gpu: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "5")]
    pub gpu_memory_gb: ::core::option::Option<u32>,
}
/// Environment information
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EnvironmentInfo {
    #[prost(string, tag = "1")]
    pub platform: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub architecture: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub container_image: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "4")]
    pub container_digest: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "5")]
    pub python_version: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(map = "string, string", tag = "6")]
    pub package_versions: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(message, optional, tag = "7")]
    pub hardware: ::core::option::Option<HardwareInfo>,
}
/// Execution metadata
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecutionMetadata {
    #[prost(string, tag = "1")]
    pub execution_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub started_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "3")]
    pub completed_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(double, tag = "4")]
    pub duration_seconds: f64,
    #[prost(message, optional, tag = "5")]
    pub environment: ::core::option::Option<EnvironmentInfo>,
    #[prost(message, optional, tag = "6")]
    pub model_parameters_used: ::core::option::Option<ModelParameters>,
    #[prost(map = "string, string", tag = "7")]
    pub dataset_checksums: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(message, optional, tag = "8")]
    pub random_seed: ::core::option::Option<u64>,
    #[prost(string, tag = "9")]
    pub executor_version: ::prost::alloc::string::String,
}
/// Verification details
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VerificationDetails {
    #[prost(double, tag = "1")]
    pub reproduced_score: f64,
    #[prost(double, tag = "2")]
    pub score_variance: f64,
    #[prost(bool, tag = "3")]
    pub environment_match: bool,
    #[prost(message, optional, tag = "4")]
    pub notes: ::core::option::Option<::prost::alloc::string::String>,
}
/// Verification status
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VerificationStatus {
    #[prost(enumeration = "VerificationLevel", tag = "1")]
    pub level: i32,
    #[prost(message, optional, tag = "2")]
    pub verified_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "3")]
    pub verified_by: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub verification_details: ::core::option::Option<VerificationDetails>,
}
/// Submission
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Submission {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub benchmark_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub benchmark_version_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub model_info: ::core::option::Option<ModelInfo>,
    #[prost(message, optional, tag = "5")]
    pub submitter: ::core::option::Option<SubmitterInfo>,
    #[prost(message, optional, tag = "6")]
    pub results: ::core::option::Option<SubmissionResults>,
    #[prost(message, optional, tag = "7")]
    pub execution_metadata: ::core::option::Option<ExecutionMetadata>,
    #[prost(message, optional, tag = "8")]
    pub verification_status: ::core::option::Option<VerificationStatus>,
    #[prost(enumeration = "SubmissionVisibility", tag = "9")]
    pub visibility: i32,
    #[prost(message, optional, tag = "10")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "11")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// Submit results request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubmitResultsRequest {
    #[prost(string, tag = "1")]
    pub benchmark_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub benchmark_version_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub model_info: ::core::option::Option<ModelInfo>,
    #[prost(message, optional, tag = "4")]
    pub results: ::core::option::Option<SubmissionResults>,
    #[prost(message, optional, tag = "5")]
    pub execution_metadata: ::core::option::Option<ExecutionMetadata>,
    #[prost(enumeration = "SubmissionVisibility", tag = "6")]
    pub visibility: i32,
}
/// Submit results response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubmitResultsResponse {
    #[prost(message, optional, tag = "1")]
    pub submission: ::core::option::Option<Submission>,
}
/// Get submission request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSubmissionRequest {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
/// Get submission response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSubmissionResponse {
    #[prost(message, optional, tag = "1")]
    pub submission: ::core::option::Option<Submission>,
}
/// List submissions request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSubmissionsRequest {
    #[prost(message, optional, tag = "1")]
    pub benchmark_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "2")]
    pub model_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "3")]
    pub user_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(enumeration = "VerificationLevel", tag = "4")]
    pub min_verification_level: i32,
    #[prost(uint32, tag = "5")]
    pub page: u32,
    #[prost(uint32, tag = "6")]
    pub page_size: u32,
    #[prost(string, tag = "7")]
    pub sort_by: ::prost::alloc::string::String,
    #[prost(bool, tag = "8")]
    pub sort_desc: bool,
}
/// List submissions response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSubmissionsResponse {
    #[prost(message, repeated, tag = "1")]
    pub submissions: ::prost::alloc::vec::Vec<Submission>,
    #[prost(uint32, tag = "2")]
    pub total_count: u32,
    #[prost(uint32, tag = "3")]
    pub page: u32,
    #[prost(uint32, tag = "4")]
    pub page_size: u32,
}
/// Request verification request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RequestVerificationRequest {
    #[prost(string, tag = "1")]
    pub submission_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub notes: ::core::option::Option<::prost::alloc::string::String>,
}
/// Request verification response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RequestVerificationResponse {
    #[prost(string, tag = "1")]
    pub verification_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub status: ::prost::alloc::string::String,
}
/// Verification level
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum VerificationLevel {
    Unspecified = 0,
    Unverified = 1,
    CommunityVerified = 2,
    PlatformVerified = 3,
    Audited = 4,
}
impl VerificationLevel {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            VerificationLevel::Unspecified => "VERIFICATION_LEVEL_UNSPECIFIED",
            VerificationLevel::Unverified => "VERIFICATION_LEVEL_UNVERIFIED",
            VerificationLevel::CommunityVerified => {
                "VERIFICATION_LEVEL_COMMUNITY_VERIFIED"
            }
            VerificationLevel::PlatformVerified => "VERIFICATION_LEVEL_PLATFORM_VERIFIED",
            VerificationLevel::Audited => "VERIFICATION_LEVEL_AUDITED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "VERIFICATION_LEVEL_UNSPECIFIED" => Some(Self::Unspecified),
            "VERIFICATION_LEVEL_UNVERIFIED" => Some(Self::Unverified),
            "VERIFICATION_LEVEL_COMMUNITY_VERIFIED" => Some(Self::CommunityVerified),
            "VERIFICATION_LEVEL_PLATFORM_VERIFIED" => Some(Self::PlatformVerified),
            "VERIFICATION_LEVEL_AUDITED" => Some(Self::Audited),
            _ => None,
        }
    }
}
/// Submission visibility
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SubmissionVisibility {
    Unspecified = 0,
    Public = 1,
    Unlisted = 2,
    Private = 3,
}
impl SubmissionVisibility {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            SubmissionVisibility::Unspecified => "SUBMISSION_VISIBILITY_UNSPECIFIED",
            SubmissionVisibility::Public => "SUBMISSION_VISIBILITY_PUBLIC",
            SubmissionVisibility::Unlisted => "SUBMISSION_VISIBILITY_UNLISTED",
            SubmissionVisibility::Private => "SUBMISSION_VISIBILITY_PRIVATE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SUBMISSION_VISIBILITY_UNSPECIFIED" => Some(Self::Unspecified),
            "SUBMISSION_VISIBILITY_PUBLIC" => Some(Self::Public),
            "SUBMISSION_VISIBILITY_UNLISTED" => Some(Self::Unlisted),
            "SUBMISSION_VISIBILITY_PRIVATE" => Some(Self::Private),
            _ => None,
        }
    }
}
/// Test case error type
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TestCaseErrorType {
    Unspecified = 0,
    Timeout = 1,
    RateLimited = 2,
    ModelError = 3,
    InvalidOutput = 4,
    EvaluationError = 5,
}
impl TestCaseErrorType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            TestCaseErrorType::Unspecified => "TEST_CASE_ERROR_TYPE_UNSPECIFIED",
            TestCaseErrorType::Timeout => "TEST_CASE_ERROR_TYPE_TIMEOUT",
            TestCaseErrorType::RateLimited => "TEST_CASE_ERROR_TYPE_RATE_LIMITED",
            TestCaseErrorType::ModelError => "TEST_CASE_ERROR_TYPE_MODEL_ERROR",
            TestCaseErrorType::InvalidOutput => "TEST_CASE_ERROR_TYPE_INVALID_OUTPUT",
            TestCaseErrorType::EvaluationError => "TEST_CASE_ERROR_TYPE_EVALUATION_ERROR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TEST_CASE_ERROR_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "TEST_CASE_ERROR_TYPE_TIMEOUT" => Some(Self::Timeout),
            "TEST_CASE_ERROR_TYPE_RATE_LIMITED" => Some(Self::RateLimited),
            "TEST_CASE_ERROR_TYPE_MODEL_ERROR" => Some(Self::ModelError),
            "TEST_CASE_ERROR_TYPE_INVALID_OUTPUT" => Some(Self::InvalidOutput),
            "TEST_CASE_ERROR_TYPE_EVALUATION_ERROR" => Some(Self::EvaluationError),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod submission_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// SubmissionService provides operations for benchmark result submissions
    #[derive(Debug, Clone)]
    pub struct SubmissionServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl SubmissionServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> SubmissionServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> SubmissionServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            SubmissionServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Submit benchmark results
        pub async fn submit_results(
            &mut self,
            request: impl tonic::IntoRequest<super::SubmitResultsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SubmitResultsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/llm_benchmark.v1.SubmissionService/SubmitResults",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "llm_benchmark.v1.SubmissionService",
                        "SubmitResults",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get a specific submission
        pub async fn get_submission(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSubmissionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetSubmissionResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/llm_benchmark.v1.SubmissionService/GetSubmission",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "llm_benchmark.v1.SubmissionService",
                        "GetSubmission",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// List submissions with filtering
        pub async fn list_submissions(
            &mut self,
            request: impl tonic::IntoRequest<super::ListSubmissionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListSubmissionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/llm_benchmark.v1.SubmissionService/ListSubmissions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "llm_benchmark.v1.SubmissionService",
                        "ListSubmissions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Request verification of a submission
        pub async fn request_verification(
            &mut self,
            request: impl tonic::IntoRequest<super::RequestVerificationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RequestVerificationResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/llm_benchmark.v1.SubmissionService/RequestVerification",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "llm_benchmark.v1.SubmissionService",
                        "RequestVerification",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod submission_service_server {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with SubmissionServiceServer.
    #[async_trait]
    pub trait SubmissionService: Send + Sync + 'static {
        /// Submit benchmark results
        async fn submit_results(
            &self,
            request: tonic::Request<super::SubmitResultsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SubmitResultsResponse>,
            tonic::Status,
        >;
        /// Get a specific submission
        async fn get_submission(
            &self,
            request: tonic::Request<super::GetSubmissionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetSubmissionResponse>,
            tonic::Status,
        >;
        /// List submissions with filtering
        async fn list_submissions(
            &self,
            request: tonic::Request<super::ListSubmissionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListSubmissionsResponse>,
            tonic::Status,
        >;
        /// Request verification of a submission
        async fn request_verification(
            &self,
            request: tonic::Request<super::RequestVerificationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RequestVerificationResponse>,
            tonic::Status,
        >;
    }
    /// SubmissionService provides operations for benchmark result submissions
    #[derive(Debug)]
    pub struct SubmissionServiceServer<T: SubmissionService> {
        inner: _Inner<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    struct _Inner<T>(Arc<T>);
    impl<T: SubmissionService> SubmissionServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            let inner = _Inner(inner);
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for SubmissionServiceServer<T>
    where
        T: SubmissionService,
        B: Body + Send + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/llm_benchmark.v1.SubmissionService/SubmitResults" => {
                    #[allow(non_camel_case_types)]
                    struct SubmitResultsSvc<T: SubmissionService>(pub Arc<T>);
                    impl<
                        T: SubmissionService,
                    > tonic::server::UnaryService<super::SubmitResultsRequest>
                    for SubmitResultsSvc<T> {
                        type Response = super::SubmitResultsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SubmitResultsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SubmissionService>::submit_results(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = SubmitResultsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/llm_benchmark.v1.SubmissionService/GetSubmission" => {
                    #[allow(non_camel_case_types)]
                    struct GetSubmissionSvc<T: SubmissionService>(pub Arc<T>);
                    impl<
                        T: SubmissionService,
                    > tonic::server::UnaryService<super::GetSubmissionRequest>
                    for GetSubmissionSvc<T> {
                        type Response = super::GetSubmissionResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetSubmissionRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SubmissionService>::get_submission(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = GetSubmissionSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/llm_benchmark.v1.SubmissionService/ListSubmissions" => {
                    #[allow(non_camel_case_types)]
                    struct ListSubmissionsSvc<T: SubmissionService>(pub Arc<T>);
                    impl<
                        T: SubmissionService,
                    > tonic::server::UnaryService<super::ListSubmissionsRequest>
                    for ListSubmissionsSvc<T> {
                        type Response = super::ListSubmissionsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListSubmissionsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SubmissionService>::list_submissions(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = ListSubmissionsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/llm_benchmark.v1.SubmissionService/RequestVerification" => {
                    #[allow(non_camel_case_types)]
                    struct RequestVerificationSvc<T: SubmissionService>(pub Arc<T>);
                    impl<
                        T: SubmissionService,
                    > tonic::server::UnaryService<super::RequestVerificationRequest>
                    for RequestVerificationSvc<T> {
                        type Response = super::RequestVerificationResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RequestVerificationRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SubmissionService>::request_verification(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = RequestVerificationSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        Ok(
                            http::Response::builder()
                                .status(200)
                                .header("grpc-status", "12")
                                .header("content-type", "application/grpc")
                                .body(empty_body())
                                .unwrap(),
                        )
                    })
                }
            }
        }
    }
    impl<T: SubmissionService> Clone for SubmissionServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    impl<T: SubmissionService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(Arc::clone(&self.0))
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: SubmissionService> tonic::server::NamedService
    for SubmissionServiceServer<T> {
        const NAME: &'static str = "llm_benchmark.v1.SubmissionService";
    }
}
/// Leaderboard entry
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LeaderboardEntry {
    #[prost(uint32, tag = "1")]
    pub rank: u32,
    #[prost(string, tag = "2")]
    pub submission_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub model_provider: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub model_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub model_version: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(double, tag = "6")]
    pub aggregate_score: f64,
    #[prost(map = "string, double", tag = "7")]
    pub metric_scores: ::std::collections::HashMap<::prost::alloc::string::String, f64>,
    #[prost(string, tag = "8")]
    pub verification_level: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "9")]
    pub submitted_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "10")]
    pub organization_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, tag = "11")]
    pub is_official: bool,
}
/// Category-specific ranking
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CategoryRanking {
    #[prost(enumeration = "BenchmarkCategory", tag = "1")]
    pub category: i32,
    #[prost(message, repeated, tag = "2")]
    pub entries: ::prost::alloc::vec::Vec<LeaderboardEntry>,
    #[prost(uint32, tag = "3")]
    pub total_entries: u32,
}
/// Model comparison result
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModelComparison {
    #[prost(string, tag = "1")]
    pub model_a_name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub model_b_name: ::prost::alloc::string::String,
    #[prost(double, tag = "3")]
    pub score_difference: f64,
    #[prost(double, tag = "4")]
    pub percent_difference: f64,
    #[prost(map = "string, double", tag = "5")]
    pub metric_differences: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        f64,
    >,
    #[prost(bool, tag = "6")]
    pub statistically_significant: bool,
    #[prost(message, optional, tag = "7")]
    pub p_value: ::core::option::Option<f64>,
}
/// Get leaderboard request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetLeaderboardRequest {
    #[prost(string, tag = "1")]
    pub benchmark_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub version: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "3")]
    pub verification_level: ::prost::alloc::string::String,
    #[prost(uint32, tag = "4")]
    pub limit: u32,
    #[prost(uint32, tag = "5")]
    pub offset: u32,
}
/// Get leaderboard response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetLeaderboardResponse {
    #[prost(string, tag = "1")]
    pub benchmark_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub benchmark_name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub version: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "4")]
    pub entries: ::prost::alloc::vec::Vec<LeaderboardEntry>,
    #[prost(uint32, tag = "5")]
    pub total_entries: u32,
    #[prost(message, optional, tag = "6")]
    pub last_updated: ::core::option::Option<::prost_types::Timestamp>,
}
/// Get category leaderboard request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCategoryLeaderboardRequest {
    #[prost(enumeration = "BenchmarkCategory", tag = "1")]
    pub category: i32,
    #[prost(string, tag = "2")]
    pub verification_level: ::prost::alloc::string::String,
    #[prost(uint32, tag = "3")]
    pub limit: u32,
}
/// Get category leaderboard response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCategoryLeaderboardResponse {
    #[prost(enumeration = "BenchmarkCategory", tag = "1")]
    pub category: i32,
    #[prost(message, repeated, tag = "2")]
    pub rankings: ::prost::alloc::vec::Vec<CategoryRanking>,
    #[prost(message, optional, tag = "3")]
    pub last_updated: ::core::option::Option<::prost_types::Timestamp>,
}
/// Compare models request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CompareModelsRequest {
    #[prost(string, tag = "1")]
    pub benchmark_id: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub submission_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, tag = "3")]
    pub include_statistical_tests: bool,
}
/// Compare models response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CompareModelsResponse {
    #[prost(message, repeated, tag = "1")]
    pub models: ::prost::alloc::vec::Vec<LeaderboardEntry>,
    #[prost(message, repeated, tag = "2")]
    pub comparisons: ::prost::alloc::vec::Vec<ModelComparison>,
    #[prost(string, tag = "3")]
    pub benchmark_name: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod leaderboard_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// LeaderboardService provides operations for retrieving leaderboard data
    #[derive(Debug, Clone)]
    pub struct LeaderboardServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl LeaderboardServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> LeaderboardServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> LeaderboardServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            LeaderboardServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Get the full leaderboard for a benchmark
        pub async fn get_leaderboard(
            &mut self,
            request: impl tonic::IntoRequest<super::GetLeaderboardRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetLeaderboardResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/llm_benchmark.v1.LeaderboardService/GetLeaderboard",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "llm_benchmark.v1.LeaderboardService",
                        "GetLeaderboard",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get leaderboard for a specific category
        pub async fn get_category_leaderboard(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCategoryLeaderboardRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetCategoryLeaderboardResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/llm_benchmark.v1.LeaderboardService/GetCategoryLeaderboard",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "llm_benchmark.v1.LeaderboardService",
                        "GetCategoryLeaderboard",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Compare multiple models
        pub async fn compare_models(
            &mut self,
            request: impl tonic::IntoRequest<super::CompareModelsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CompareModelsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/llm_benchmark.v1.LeaderboardService/CompareModels",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "llm_benchmark.v1.LeaderboardService",
                        "CompareModels",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod leaderboard_service_server {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with LeaderboardServiceServer.
    #[async_trait]
    pub trait LeaderboardService: Send + Sync + 'static {
        /// Get the full leaderboard for a benchmark
        async fn get_leaderboard(
            &self,
            request: tonic::Request<super::GetLeaderboardRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetLeaderboardResponse>,
            tonic::Status,
        >;
        /// Get leaderboard for a specific category
        async fn get_category_leaderboard(
            &self,
            request: tonic::Request<super::GetCategoryLeaderboardRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetCategoryLeaderboardResponse>,
            tonic::Status,
        >;
        /// Compare multiple models
        async fn compare_models(
            &self,
            request: tonic::Request<super::CompareModelsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CompareModelsResponse>,
            tonic::Status,
        >;
    }
    /// LeaderboardService provides operations for retrieving leaderboard data
    #[derive(Debug)]
    pub struct LeaderboardServiceServer<T: LeaderboardService> {
        inner: _Inner<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    struct _Inner<T>(Arc<T>);
    impl<T: LeaderboardService> LeaderboardServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            let inner = _Inner(inner);
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for LeaderboardServiceServer<T>
    where
        T: LeaderboardService,
        B: Body + Send + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/llm_benchmark.v1.LeaderboardService/GetLeaderboard" => {
                    #[allow(non_camel_case_types)]
                    struct GetLeaderboardSvc<T: LeaderboardService>(pub Arc<T>);
                    impl<
                        T: LeaderboardService,
                    > tonic::server::UnaryService<super::GetLeaderboardRequest>
                    for GetLeaderboardSvc<T> {
                        type Response = super::GetLeaderboardResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetLeaderboardRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as LeaderboardService>::get_leaderboard(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = GetLeaderboardSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/llm_benchmark.v1.LeaderboardService/GetCategoryLeaderboard" => {
                    #[allow(non_camel_case_types)]
                    struct GetCategoryLeaderboardSvc<T: LeaderboardService>(pub Arc<T>);
                    impl<
                        T: LeaderboardService,
                    > tonic::server::UnaryService<super::GetCategoryLeaderboardRequest>
                    for GetCategoryLeaderboardSvc<T> {
                        type Response = super::GetCategoryLeaderboardResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetCategoryLeaderboardRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as LeaderboardService>::get_category_leaderboard(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = GetCategoryLeaderboardSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/llm_benchmark.v1.LeaderboardService/CompareModels" => {
                    #[allow(non_camel_case_types)]
                    struct CompareModelsSvc<T: LeaderboardService>(pub Arc<T>);
                    impl<
                        T: LeaderboardService,
                    > tonic::server::UnaryService<super::CompareModelsRequest>
                    for CompareModelsSvc<T> {
                        type Response = super::CompareModelsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CompareModelsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as LeaderboardService>::compare_models(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = CompareModelsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        Ok(
                            http::Response::builder()
                                .status(200)
                                .header("grpc-status", "12")
                                .header("content-type", "application/grpc")
                                .body(empty_body())
                                .unwrap(),
                        )
                    })
                }
            }
        }
    }
    impl<T: LeaderboardService> Clone for LeaderboardServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    impl<T: LeaderboardService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(Arc::clone(&self.0))
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: LeaderboardService> tonic::server::NamedService
    for LeaderboardServiceServer<T> {
        const NAME: &'static str = "llm_benchmark.v1.LeaderboardService";
    }
}
/// Voting state
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VotingState {
    #[prost(message, optional, tag = "1")]
    pub voting_starts: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "2")]
    pub voting_ends: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(uint32, tag = "3")]
    pub votes_for: u32,
    #[prost(uint32, tag = "4")]
    pub votes_against: u32,
    #[prost(uint32, tag = "5")]
    pub votes_abstain: u32,
    #[prost(string, repeated, tag = "6")]
    pub voters: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(uint32, tag = "7")]
    pub quorum_required: u32,
    #[prost(double, tag = "8")]
    pub approval_threshold: f64,
}
/// Line reference
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LineReference {
    #[prost(string, tag = "1")]
    pub file: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub start_line: u32,
    #[prost(message, optional, tag = "3")]
    pub end_line: ::core::option::Option<u32>,
}
/// Review comment
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReviewComment {
    #[prost(string, tag = "1")]
    pub content: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub line_references: ::prost::alloc::vec::Vec<LineReference>,
}
/// Review
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Review {
    #[prost(string, tag = "1")]
    pub reviewer_id: ::prost::alloc::string::String,
    #[prost(enumeration = "ReviewStatus", tag = "2")]
    pub status: i32,
    #[prost(message, repeated, tag = "3")]
    pub comments: ::prost::alloc::vec::Vec<ReviewComment>,
    #[prost(message, optional, tag = "4")]
    pub submitted_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// Proposal
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Proposal {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(enumeration = "ProposalType", tag = "2")]
    pub proposal_type: i32,
    #[prost(string, tag = "3")]
    pub title: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub created_by: ::prost::alloc::string::String,
    #[prost(enumeration = "ProposalStatus", tag = "6")]
    pub status: i32,
    #[prost(message, optional, tag = "7")]
    pub benchmark_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "8")]
    pub rationale: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "9")]
    pub voting: ::core::option::Option<VotingState>,
    #[prost(message, repeated, tag = "10")]
    pub reviews: ::prost::alloc::vec::Vec<Review>,
    #[prost(message, optional, tag = "11")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "12")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// Create proposal request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateProposalRequest {
    #[prost(enumeration = "ProposalType", tag = "1")]
    pub proposal_type: i32,
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub benchmark_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "5")]
    pub rationale: ::prost::alloc::string::String,
}
/// Create proposal response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateProposalResponse {
    #[prost(message, optional, tag = "1")]
    pub proposal: ::core::option::Option<Proposal>,
}
/// Get proposal request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetProposalRequest {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
/// Get proposal response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetProposalResponse {
    #[prost(message, optional, tag = "1")]
    pub proposal: ::core::option::Option<Proposal>,
}
/// List proposals request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListProposalsRequest {
    #[prost(enumeration = "ProposalType", tag = "1")]
    pub proposal_type: i32,
    #[prost(enumeration = "ProposalStatus", tag = "2")]
    pub status: i32,
    #[prost(message, optional, tag = "3")]
    pub created_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, tag = "4")]
    pub page: u32,
    #[prost(uint32, tag = "5")]
    pub page_size: u32,
    #[prost(string, tag = "6")]
    pub sort_by: ::prost::alloc::string::String,
    #[prost(bool, tag = "7")]
    pub sort_desc: bool,
}
/// List proposals response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListProposalsResponse {
    #[prost(message, repeated, tag = "1")]
    pub proposals: ::prost::alloc::vec::Vec<Proposal>,
    #[prost(uint32, tag = "2")]
    pub total_count: u32,
    #[prost(uint32, tag = "3")]
    pub page: u32,
    #[prost(uint32, tag = "4")]
    pub page_size: u32,
}
/// Cast vote request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CastVoteRequest {
    #[prost(string, tag = "1")]
    pub proposal_id: ::prost::alloc::string::String,
    #[prost(enumeration = "Vote", tag = "2")]
    pub vote: i32,
    #[prost(message, optional, tag = "3")]
    pub comment: ::core::option::Option<::prost::alloc::string::String>,
}
/// Cast vote response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CastVoteResponse {
    #[prost(message, optional, tag = "1")]
    pub proposal: ::core::option::Option<Proposal>,
    #[prost(string, tag = "2")]
    pub vote_recorded: ::prost::alloc::string::String,
}
/// Proposal types
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ProposalType {
    Unspecified = 0,
    NewBenchmark = 1,
    UpdateBenchmark = 2,
    DeprecateBenchmark = 3,
    PolicyChange = 4,
}
impl ProposalType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ProposalType::Unspecified => "PROPOSAL_TYPE_UNSPECIFIED",
            ProposalType::NewBenchmark => "PROPOSAL_TYPE_NEW_BENCHMARK",
            ProposalType::UpdateBenchmark => "PROPOSAL_TYPE_UPDATE_BENCHMARK",
            ProposalType::DeprecateBenchmark => "PROPOSAL_TYPE_DEPRECATE_BENCHMARK",
            ProposalType::PolicyChange => "PROPOSAL_TYPE_POLICY_CHANGE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PROPOSAL_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "PROPOSAL_TYPE_NEW_BENCHMARK" => Some(Self::NewBenchmark),
            "PROPOSAL_TYPE_UPDATE_BENCHMARK" => Some(Self::UpdateBenchmark),
            "PROPOSAL_TYPE_DEPRECATE_BENCHMARK" => Some(Self::DeprecateBenchmark),
            "PROPOSAL_TYPE_POLICY_CHANGE" => Some(Self::PolicyChange),
            _ => None,
        }
    }
}
/// Proposal status
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ProposalStatus {
    Unspecified = 0,
    Draft = 1,
    UnderReview = 2,
    Voting = 3,
    Approved = 4,
    Rejected = 5,
    Withdrawn = 6,
}
impl ProposalStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ProposalStatus::Unspecified => "PROPOSAL_STATUS_UNSPECIFIED",
            ProposalStatus::Draft => "PROPOSAL_STATUS_DRAFT",
            ProposalStatus::UnderReview => "PROPOSAL_STATUS_UNDER_REVIEW",
            ProposalStatus::Voting => "PROPOSAL_STATUS_VOTING",
            ProposalStatus::Approved => "PROPOSAL_STATUS_APPROVED",
            ProposalStatus::Rejected => "PROPOSAL_STATUS_REJECTED",
            ProposalStatus::Withdrawn => "PROPOSAL_STATUS_WITHDRAWN",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PROPOSAL_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "PROPOSAL_STATUS_DRAFT" => Some(Self::Draft),
            "PROPOSAL_STATUS_UNDER_REVIEW" => Some(Self::UnderReview),
            "PROPOSAL_STATUS_VOTING" => Some(Self::Voting),
            "PROPOSAL_STATUS_APPROVED" => Some(Self::Approved),
            "PROPOSAL_STATUS_REJECTED" => Some(Self::Rejected),
            "PROPOSAL_STATUS_WITHDRAWN" => Some(Self::Withdrawn),
            _ => None,
        }
    }
}
/// Vote type
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Vote {
    Unspecified = 0,
    Approve = 1,
    Reject = 2,
    Abstain = 3,
}
impl Vote {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Vote::Unspecified => "VOTE_UNSPECIFIED",
            Vote::Approve => "VOTE_APPROVE",
            Vote::Reject => "VOTE_REJECT",
            Vote::Abstain => "VOTE_ABSTAIN",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "VOTE_UNSPECIFIED" => Some(Self::Unspecified),
            "VOTE_APPROVE" => Some(Self::Approve),
            "VOTE_REJECT" => Some(Self::Reject),
            "VOTE_ABSTAIN" => Some(Self::Abstain),
            _ => None,
        }
    }
}
/// Review status
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ReviewStatus {
    Unspecified = 0,
    Pending = 1,
    Approved = 2,
    RequestChanges = 3,
    Rejected = 4,
}
impl ReviewStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ReviewStatus::Unspecified => "REVIEW_STATUS_UNSPECIFIED",
            ReviewStatus::Pending => "REVIEW_STATUS_PENDING",
            ReviewStatus::Approved => "REVIEW_STATUS_APPROVED",
            ReviewStatus::RequestChanges => "REVIEW_STATUS_REQUEST_CHANGES",
            ReviewStatus::Rejected => "REVIEW_STATUS_REJECTED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "REVIEW_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "REVIEW_STATUS_PENDING" => Some(Self::Pending),
            "REVIEW_STATUS_APPROVED" => Some(Self::Approved),
            "REVIEW_STATUS_REQUEST_CHANGES" => Some(Self::RequestChanges),
            "REVIEW_STATUS_REJECTED" => Some(Self::Rejected),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod governance_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// GovernanceService provides operations for community governance
    #[derive(Debug, Clone)]
    pub struct GovernanceServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl GovernanceServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> GovernanceServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> GovernanceServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            GovernanceServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Create a new proposal
        pub async fn create_proposal(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateProposalRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateProposalResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/llm_benchmark.v1.GovernanceService/CreateProposal",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "llm_benchmark.v1.GovernanceService",
                        "CreateProposal",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get a specific proposal
        pub async fn get_proposal(
            &mut self,
            request: impl tonic::IntoRequest<super::GetProposalRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetProposalResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/llm_benchmark.v1.GovernanceService/GetProposal",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("llm_benchmark.v1.GovernanceService", "GetProposal"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// List proposals with filtering
        pub async fn list_proposals(
            &mut self,
            request: impl tonic::IntoRequest<super::ListProposalsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListProposalsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/llm_benchmark.v1.GovernanceService/ListProposals",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "llm_benchmark.v1.GovernanceService",
                        "ListProposals",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Cast a vote on a proposal
        pub async fn cast_vote(
            &mut self,
            request: impl tonic::IntoRequest<super::CastVoteRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CastVoteResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/llm_benchmark.v1.GovernanceService/CastVote",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("llm_benchmark.v1.GovernanceService", "CastVote"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod governance_service_server {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with GovernanceServiceServer.
    #[async_trait]
    pub trait GovernanceService: Send + Sync + 'static {
        /// Create a new proposal
        async fn create_proposal(
            &self,
            request: tonic::Request<super::CreateProposalRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateProposalResponse>,
            tonic::Status,
        >;
        /// Get a specific proposal
        async fn get_proposal(
            &self,
            request: tonic::Request<super::GetProposalRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetProposalResponse>,
            tonic::Status,
        >;
        /// List proposals with filtering
        async fn list_proposals(
            &self,
            request: tonic::Request<super::ListProposalsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListProposalsResponse>,
            tonic::Status,
        >;
        /// Cast a vote on a proposal
        async fn cast_vote(
            &self,
            request: tonic::Request<super::CastVoteRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CastVoteResponse>,
            tonic::Status,
        >;
    }
    /// GovernanceService provides operations for community governance
    #[derive(Debug)]
    pub struct GovernanceServiceServer<T: GovernanceService> {
        inner: _Inner<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    struct _Inner<T>(Arc<T>);
    impl<T: GovernanceService> GovernanceServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            let inner = _Inner(inner);
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for GovernanceServiceServer<T>
    where
        T: GovernanceService,
        B: Body + Send + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/llm_benchmark.v1.GovernanceService/CreateProposal" => {
                    #[allow(non_camel_case_types)]
                    struct CreateProposalSvc<T: GovernanceService>(pub Arc<T>);
                    impl<
                        T: GovernanceService,
                    > tonic::server::UnaryService<super::CreateProposalRequest>
                    for CreateProposalSvc<T> {
                        type Response = super::CreateProposalResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateProposalRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as GovernanceService>::create_proposal(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = CreateProposalSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/llm_benchmark.v1.GovernanceService/GetProposal" => {
                    #[allow(non_camel_case_types)]
                    struct GetProposalSvc<T: GovernanceService>(pub Arc<T>);
                    impl<
                        T: GovernanceService,
                    > tonic::server::UnaryService<super::GetProposalRequest>
                    for GetProposalSvc<T> {
                        type Response = super::GetProposalResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetProposalRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as GovernanceService>::get_proposal(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = GetProposalSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/llm_benchmark.v1.GovernanceService/ListProposals" => {
                    #[allow(non_camel_case_types)]
                    struct ListProposalsSvc<T: GovernanceService>(pub Arc<T>);
                    impl<
                        T: GovernanceService,
                    > tonic::server::UnaryService<super::ListProposalsRequest>
                    for ListProposalsSvc<T> {
                        type Response = super::ListProposalsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListProposalsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as GovernanceService>::list_proposals(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = ListProposalsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/llm_benchmark.v1.GovernanceService/CastVote" => {
                    #[allow(non_camel_case_types)]
                    struct CastVoteSvc<T: GovernanceService>(pub Arc<T>);
                    impl<
                        T: GovernanceService,
                    > tonic::server::UnaryService<super::CastVoteRequest>
                    for CastVoteSvc<T> {
                        type Response = super::CastVoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CastVoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as GovernanceService>::cast_vote(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = CastVoteSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        Ok(
                            http::Response::builder()
                                .status(200)
                                .header("grpc-status", "12")
                                .header("content-type", "application/grpc")
                                .body(empty_body())
                                .unwrap(),
                        )
                    })
                }
            }
        }
    }
    impl<T: GovernanceService> Clone for GovernanceServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    impl<T: GovernanceService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(Arc::clone(&self.0))
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: GovernanceService> tonic::server::NamedService
    for GovernanceServiceServer<T> {
        const NAME: &'static str = "llm_benchmark.v1.GovernanceService";
    }
}
/// User profile
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserProfile {
    #[prost(message, optional, tag = "1")]
    pub bio: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "2")]
    pub affiliation: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "3")]
    pub website: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "4")]
    pub github_username: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "5")]
    pub orcid: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "6")]
    pub public_email: ::core::option::Option<::prost::alloc::string::String>,
}
/// Organization membership
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OrganizationMembership {
    #[prost(string, tag = "1")]
    pub organization_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub organization_name: ::prost::alloc::string::String,
    #[prost(enumeration = "OrganizationRole", tag = "3")]
    pub role: i32,
    #[prost(message, optional, tag = "4")]
    pub joined_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// User
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct User {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub email: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub username: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub display_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(enumeration = "UserRole", tag = "5")]
    pub role: i32,
    #[prost(message, repeated, tag = "6")]
    pub organizations: ::prost::alloc::vec::Vec<OrganizationMembership>,
    #[prost(message, optional, tag = "7")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "8")]
    pub last_active_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(bool, tag = "9")]
    pub email_verified: bool,
    #[prost(message, optional, tag = "10")]
    pub profile: ::core::option::Option<UserProfile>,
}
/// Organization
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Organization {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub slug: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "5")]
    pub website: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "6")]
    pub logo_url: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(enumeration = "OrganizationType", tag = "7")]
    pub organization_type: i32,
    #[prost(bool, tag = "8")]
    pub verified: bool,
    #[prost(message, optional, tag = "9")]
    pub verification_date: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "10")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// Register request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegisterRequest {
    #[prost(string, tag = "1")]
    pub email: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub username: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub password: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub display_name: ::core::option::Option<::prost::alloc::string::String>,
}
/// Register response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegisterResponse {
    #[prost(message, optional, tag = "1")]
    pub user: ::core::option::Option<User>,
    #[prost(string, tag = "2")]
    pub access_token: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub refresh_token: ::prost::alloc::string::String,
}
/// Login request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LoginRequest {
    #[prost(string, tag = "1")]
    pub email_or_username: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub password: ::prost::alloc::string::String,
}
/// Login response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LoginResponse {
    #[prost(message, optional, tag = "1")]
    pub user: ::core::option::Option<User>,
    #[prost(string, tag = "2")]
    pub access_token: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub refresh_token: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub expires_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// Get profile request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetProfileRequest {
    #[prost(message, optional, tag = "1")]
    pub user_id: ::core::option::Option<::prost::alloc::string::String>,
}
/// Get profile response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetProfileResponse {
    #[prost(message, optional, tag = "1")]
    pub user: ::core::option::Option<User>,
}
/// Update profile request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateProfileRequest {
    #[prost(message, optional, tag = "1")]
    pub display_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "2")]
    pub profile: ::core::option::Option<UserProfile>,
}
/// Update profile response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateProfileResponse {
    #[prost(message, optional, tag = "1")]
    pub user: ::core::option::Option<User>,
}
/// User roles
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum UserRole {
    Unspecified = 0,
    Anonymous = 1,
    Registered = 2,
    Contributor = 3,
    Reviewer = 4,
    Admin = 5,
}
impl UserRole {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            UserRole::Unspecified => "USER_ROLE_UNSPECIFIED",
            UserRole::Anonymous => "USER_ROLE_ANONYMOUS",
            UserRole::Registered => "USER_ROLE_REGISTERED",
            UserRole::Contributor => "USER_ROLE_CONTRIBUTOR",
            UserRole::Reviewer => "USER_ROLE_REVIEWER",
            UserRole::Admin => "USER_ROLE_ADMIN",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "USER_ROLE_UNSPECIFIED" => Some(Self::Unspecified),
            "USER_ROLE_ANONYMOUS" => Some(Self::Anonymous),
            "USER_ROLE_REGISTERED" => Some(Self::Registered),
            "USER_ROLE_CONTRIBUTOR" => Some(Self::Contributor),
            "USER_ROLE_REVIEWER" => Some(Self::Reviewer),
            "USER_ROLE_ADMIN" => Some(Self::Admin),
            _ => None,
        }
    }
}
/// Organization types
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum OrganizationType {
    Unspecified = 0,
    LlmProvider = 1,
    ResearchInstitution = 2,
    Enterprise = 3,
    OpenSource = 4,
    Individual = 5,
}
impl OrganizationType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            OrganizationType::Unspecified => "ORGANIZATION_TYPE_UNSPECIFIED",
            OrganizationType::LlmProvider => "ORGANIZATION_TYPE_LLM_PROVIDER",
            OrganizationType::ResearchInstitution => {
                "ORGANIZATION_TYPE_RESEARCH_INSTITUTION"
            }
            OrganizationType::Enterprise => "ORGANIZATION_TYPE_ENTERPRISE",
            OrganizationType::OpenSource => "ORGANIZATION_TYPE_OPEN_SOURCE",
            OrganizationType::Individual => "ORGANIZATION_TYPE_INDIVIDUAL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ORGANIZATION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "ORGANIZATION_TYPE_LLM_PROVIDER" => Some(Self::LlmProvider),
            "ORGANIZATION_TYPE_RESEARCH_INSTITUTION" => Some(Self::ResearchInstitution),
            "ORGANIZATION_TYPE_ENTERPRISE" => Some(Self::Enterprise),
            "ORGANIZATION_TYPE_OPEN_SOURCE" => Some(Self::OpenSource),
            "ORGANIZATION_TYPE_INDIVIDUAL" => Some(Self::Individual),
            _ => None,
        }
    }
}
/// Organization role
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum OrganizationRole {
    Unspecified = 0,
    Member = 1,
    Admin = 2,
    Owner = 3,
}
impl OrganizationRole {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            OrganizationRole::Unspecified => "ORGANIZATION_ROLE_UNSPECIFIED",
            OrganizationRole::Member => "ORGANIZATION_ROLE_MEMBER",
            OrganizationRole::Admin => "ORGANIZATION_ROLE_ADMIN",
            OrganizationRole::Owner => "ORGANIZATION_ROLE_OWNER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ORGANIZATION_ROLE_UNSPECIFIED" => Some(Self::Unspecified),
            "ORGANIZATION_ROLE_MEMBER" => Some(Self::Member),
            "ORGANIZATION_ROLE_ADMIN" => Some(Self::Admin),
            "ORGANIZATION_ROLE_OWNER" => Some(Self::Owner),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod user_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// UserService provides operations for user management and authentication
    #[derive(Debug, Clone)]
    pub struct UserServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl UserServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> UserServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> UserServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            UserServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Register a new user account
        pub async fn register(
            &mut self,
            request: impl tonic::IntoRequest<super::RegisterRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RegisterResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/llm_benchmark.v1.UserService/Register",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("llm_benchmark.v1.UserService", "Register"));
            self.inner.unary(req, path, codec).await
        }
        /// Login and obtain authentication token
        pub async fn login(
            &mut self,
            request: impl tonic::IntoRequest<super::LoginRequest>,
        ) -> std::result::Result<tonic::Response<super::LoginResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/llm_benchmark.v1.UserService/Login",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("llm_benchmark.v1.UserService", "Login"));
            self.inner.unary(req, path, codec).await
        }
        /// Get user profile
        pub async fn get_profile(
            &mut self,
            request: impl tonic::IntoRequest<super::GetProfileRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetProfileResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/llm_benchmark.v1.UserService/GetProfile",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("llm_benchmark.v1.UserService", "GetProfile"));
            self.inner.unary(req, path, codec).await
        }
        /// Update user profile
        pub async fn update_profile(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateProfileRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateProfileResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/llm_benchmark.v1.UserService/UpdateProfile",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("llm_benchmark.v1.UserService", "UpdateProfile"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod user_service_server {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with UserServiceServer.
    #[async_trait]
    pub trait UserService: Send + Sync + 'static {
        /// Register a new user account
        async fn register(
            &self,
            request: tonic::Request<super::RegisterRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RegisterResponse>,
            tonic::Status,
        >;
        /// Login and obtain authentication token
        async fn login(
            &self,
            request: tonic::Request<super::LoginRequest>,
        ) -> std::result::Result<tonic::Response<super::LoginResponse>, tonic::Status>;
        /// Get user profile
        async fn get_profile(
            &self,
            request: tonic::Request<super::GetProfileRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetProfileResponse>,
            tonic::Status,
        >;
        /// Update user profile
        async fn update_profile(
            &self,
            request: tonic::Request<super::UpdateProfileRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateProfileResponse>,
            tonic::Status,
        >;
    }
    /// UserService provides operations for user management and authentication
    #[derive(Debug)]
    pub struct UserServiceServer<T: UserService> {
        inner: _Inner<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    struct _Inner<T>(Arc<T>);
    impl<T: UserService> UserServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            let inner = _Inner(inner);
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for UserServiceServer<T>
    where
        T: UserService,
        B: Body + Send + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/llm_benchmark.v1.UserService/Register" => {
                    #[allow(non_camel_case_types)]
                    struct RegisterSvc<T: UserService>(pub Arc<T>);
                    impl<
                        T: UserService,
                    > tonic::server::UnaryService<super::RegisterRequest>
                    for RegisterSvc<T> {
                        type Response = super::RegisterResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RegisterRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as UserService>::register(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = RegisterSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/llm_benchmark.v1.UserService/Login" => {
                    #[allow(non_camel_case_types)]
                    struct LoginSvc<T: UserService>(pub Arc<T>);
                    impl<T: UserService> tonic::server::UnaryService<super::LoginRequest>
                    for LoginSvc<T> {
                        type Response = super::LoginResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::LoginRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as UserService>::login(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = LoginSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/llm_benchmark.v1.UserService/GetProfile" => {
                    #[allow(non_camel_case_types)]
                    struct GetProfileSvc<T: UserService>(pub Arc<T>);
                    impl<
                        T: UserService,
                    > tonic::server::UnaryService<super::GetProfileRequest>
                    for GetProfileSvc<T> {
                        type Response = super::GetProfileResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetProfileRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as UserService>::get_profile(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = GetProfileSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/llm_benchmark.v1.UserService/UpdateProfile" => {
                    #[allow(non_camel_case_types)]
                    struct UpdateProfileSvc<T: UserService>(pub Arc<T>);
                    impl<
                        T: UserService,
                    > tonic::server::UnaryService<super::UpdateProfileRequest>
                    for UpdateProfileSvc<T> {
                        type Response = super::UpdateProfileResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpdateProfileRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as UserService>::update_profile(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = UpdateProfileSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        Ok(
                            http::Response::builder()
                                .status(200)
                                .header("grpc-status", "12")
                                .header("content-type", "application/grpc")
                                .body(empty_body())
                                .unwrap(),
                        )
                    })
                }
            }
        }
    }
    impl<T: UserService> Clone for UserServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    impl<T: UserService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(Arc::clone(&self.0))
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: UserService> tonic::server::NamedService for UserServiceServer<T> {
        const NAME: &'static str = "llm_benchmark.v1.UserService";
    }
}
