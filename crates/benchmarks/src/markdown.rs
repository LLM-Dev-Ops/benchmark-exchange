//! Markdown generation for benchmark results.
//!
//! This module provides functions for generating markdown reports from benchmark results.

use std::fs::{self, File};
use std::io::{BufWriter, Write};
use std::path::{Path, PathBuf};

use anyhow::{Context, Result};
use chrono::Utc;

use crate::io::SUMMARY_FILE;
use crate::result::BenchmarkResult;

/// Generates a markdown summary of benchmark results.
///
/// # Arguments
///
/// * `results` - The benchmark results to summarize
///
/// # Returns
///
/// A string containing the markdown summary.
pub fn generate_summary(results: &[BenchmarkResult]) -> String {
    let mut md = String::new();

    // Header
    md.push_str("# Benchmark Results Summary\n\n");
    md.push_str(&format!(
        "Generated: {}\n\n",
        Utc::now().format("%Y-%m-%d %H:%M:%S UTC")
    ));

    // Overview
    md.push_str("## Overview\n\n");
    md.push_str(&format!("Total benchmarks executed: **{}**\n\n", results.len()));

    if results.is_empty() {
        md.push_str("No benchmark results available.\n");
        return md;
    }

    // Results table
    md.push_str("## Results\n\n");
    md.push_str("| Target | Timestamp | Key Metrics |\n");
    md.push_str("|--------|-----------|-------------|\n");

    for result in results {
        let key_metrics = extract_key_metrics(&result.metrics);
        md.push_str(&format!(
            "| {} | {} | {} |\n",
            result.target_id,
            result.timestamp.format("%Y-%m-%d %H:%M:%S"),
            key_metrics
        ));
    }

    md.push('\n');

    // Detailed results
    md.push_str("## Detailed Results\n\n");

    for result in results {
        md.push_str(&format!("### {}\n\n", result.target_id));
        md.push_str(&format!(
            "**Executed:** {}\n\n",
            result.timestamp.format("%Y-%m-%d %H:%M:%S UTC")
        ));
        md.push_str("**Metrics:**\n\n");
        md.push_str("```json\n");
        md.push_str(&serde_json::to_string_pretty(&result.metrics).unwrap_or_default());
        md.push_str("\n```\n\n");
    }

    // Footer
    md.push_str("---\n\n");
    md.push_str("*Generated by LLM Benchmark Exchange canonical benchmark interface*\n");

    md
}

/// Extracts key metrics from a metrics JSON value for display in a summary table.
fn extract_key_metrics(metrics: &serde_json::Value) -> String {
    let mut key_metrics = Vec::new();

    if let Some(obj) = metrics.as_object() {
        // Look for common metric names
        let common_keys = [
            "duration_ms",
            "duration",
            "latency_ms",
            "latency",
            "throughput",
            "items_per_second",
            "operations_per_second",
            "total_items",
            "success_rate",
            "error_count",
        ];

        for key in common_keys {
            if let Some(value) = obj.get(key) {
                let formatted = format_metric_value(key, value);
                if !formatted.is_empty() {
                    key_metrics.push(formatted);
                }
                if key_metrics.len() >= 3 {
                    break;
                }
            }
        }

        // If no common keys found, take first 3 numeric values
        if key_metrics.is_empty() {
            for (key, value) in obj.iter().take(3) {
                if value.is_number() || value.is_string() {
                    key_metrics.push(format!("{}: {}", key, value));
                }
            }
        }
    }

    if key_metrics.is_empty() {
        "N/A".to_string()
    } else {
        key_metrics.join(", ")
    }
}

/// Formats a metric value for display.
fn format_metric_value(key: &str, value: &serde_json::Value) -> String {
    match value {
        serde_json::Value::Number(n) => {
            if key.contains("ms") || key.contains("duration") || key.contains("latency") {
                if let Some(f) = n.as_f64() {
                    return format!("{}: {:.2}ms", key, f);
                }
            }
            format!("{}: {}", key, n)
        }
        serde_json::Value::String(s) => format!("{}: {}", key, s),
        _ => String::new(),
    }
}

/// Writes a markdown summary to the canonical summary file.
///
/// # Arguments
///
/// * `results` - The benchmark results to summarize
/// * `base_path` - Optional base path (defaults to current directory)
///
/// # Returns
///
/// The path to the written file on success.
pub fn write_summary(results: &[BenchmarkResult], base_path: Option<&Path>) -> Result<PathBuf> {
    let base = base_path.unwrap_or(Path::new("."));
    let summary_path = base.join(SUMMARY_FILE);

    // Ensure parent directory exists
    if let Some(parent) = summary_path.parent() {
        fs::create_dir_all(parent)
            .with_context(|| format!("Failed to create directory: {}", parent.display()))?;
    }

    let markdown = generate_summary(results);

    let file = File::create(&summary_path)
        .with_context(|| format!("Failed to create file: {}", summary_path.display()))?;
    let mut writer = BufWriter::new(file);

    writer.write_all(markdown.as_bytes())
        .with_context(|| "Failed to write summary")?;

    writer.flush()?;

    Ok(summary_path)
}

/// Appends benchmark results to an existing summary file.
///
/// # Arguments
///
/// * `results` - The new benchmark results to append
/// * `base_path` - Optional base path (defaults to current directory)
///
/// # Returns
///
/// The path to the updated file on success.
pub fn append_to_summary(results: &[BenchmarkResult], base_path: Option<&Path>) -> Result<PathBuf> {
    let base = base_path.unwrap_or(Path::new("."));
    let summary_path = base.join(SUMMARY_FILE);

    // If file doesn't exist, just write a new one
    if !summary_path.exists() {
        return write_summary(results, base_path);
    }

    // Read existing content
    let existing = fs::read_to_string(&summary_path)
        .with_context(|| format!("Failed to read existing summary: {}", summary_path.display()))?;

    // Generate new section
    let mut new_section = String::new();
    new_section.push_str(&format!(
        "\n## Run: {}\n\n",
        Utc::now().format("%Y-%m-%d %H:%M:%S UTC")
    ));

    for result in results {
        new_section.push_str(&format!("### {}\n\n", result.target_id));
        new_section.push_str("```json\n");
        new_section.push_str(&serde_json::to_string_pretty(&result.metrics).unwrap_or_default());
        new_section.push_str("\n```\n\n");
    }

    // Insert before footer if present, otherwise append
    let updated = if existing.contains("---\n\n*Generated by") {
        existing.replacen(
            "---\n\n*Generated by",
            &format!("{}---\n\n*Generated by", new_section),
            1,
        )
    } else {
        format!("{}{}", existing, new_section)
    };

    fs::write(&summary_path, updated)
        .with_context(|| format!("Failed to write summary: {}", summary_path.display()))?;

    Ok(summary_path)
}

#[cfg(test)]
mod tests {
    use super::*;
    use serde_json::json;
    use tempfile::TempDir;

    #[test]
    fn test_generate_summary_empty() {
        let summary = generate_summary(&[]);
        assert!(summary.contains("Total benchmarks executed: **0**"));
        assert!(summary.contains("No benchmark results available"));
    }

    #[test]
    fn test_generate_summary_with_results() {
        let results = vec![
            BenchmarkResult::new(
                "test-target-1".to_string(),
                json!({"duration_ms": 100, "items": 50}),
            ),
            BenchmarkResult::new(
                "test-target-2".to_string(),
                json!({"throughput": 1000}),
            ),
        ];

        let summary = generate_summary(&results);
        assert!(summary.contains("Total benchmarks executed: **2**"));
        assert!(summary.contains("test-target-1"));
        assert!(summary.contains("test-target-2"));
    }

    #[test]
    fn test_write_summary() {
        let temp_dir = TempDir::new().unwrap();
        let results = vec![BenchmarkResult::new(
            "test".to_string(),
            json!({"value": 42}),
        )];

        let path = write_summary(&results, Some(temp_dir.path())).unwrap();
        assert!(path.exists());

        let content = fs::read_to_string(&path).unwrap();
        assert!(content.contains("test"));
    }
}
